# 2018-05-08-long-note-正则 #

- 首先是相关方法 test、exec、match和replace

a.test(reg)  用来验证字符串是否符合正则 符合返回true 否则返回false
a.match(reg) 如果匹配成功，就返回匹配成功的数组，如果匹配不成功，就返回null
reg.exec(str);  用来捕获符合规则的字符串,参数和match相反
a.replace(reg, '') 查找并替换

- 字面量创建方式 | 实例创建方式
        var reg = /pattern/flags
        // 字面量创建方式
        var reg = new RegExp(pattern,flags);
        //实例创建方式
        
        pattern:正则表达式  
        flags:标识(修饰符)
        标识主要包括：
        1. i 忽略大小写匹配
        2. m 多行匹配，即在到达一行文本末尾时还会继续寻常下一行中是否与正则匹配的项
        3. g 全局匹配 模式应用于所有字符串，而非在找到第一个匹配项时停止
        
- 字面量创建方式和构造函数创建方式的区别

1.字面量创建方式不能进行字符串拼接，实例创建方式可以

        var regParam = 'cm';
        var reg1 = new RegExp(regParam+'1');
        var reg2 = /regParam/;
        console.log(reg1);  //   /cm1/
        console.log(reg2);  //  /regParam/

2.字面量创建方式特殊含义的字符不需要转义，实例创建方式需要转义

        var reg1 = new RegExp('\d');  //    /d/ 
        var reg2 = new RegExp('\\d')  //   /\d/
        var reg3 = /\d/;              //  /\d/
        
## 元字符 ##

- 代表特殊含义的元字符

        \d : 0-9之间的任意一个数字  \d只占一个位置
        \w : 数字，字母 ，下划线 0-9 a-z A-Z _
        \s : 空格或者空白等
        \D : 除了\d
        \W : 除了\w
        \S : 除了\s
         . : 除了\n之外的任意一个字符
         \ : 转义字符
         | : 或者
        () : 分组
        \n : 匹配换行符
        \b : 匹配边界 字符串的开头和结尾 空格的两边都是边界 => 不占用字符串位数
         ^ : 限定开始位置 => 本身不占位置
         $ : 限定结束位置 => 本身不占位置
        [a-z] : 任意字母 []中的表示任意一个都可以
        [^a-z] : 非字母 []中^代表除了
        [abc] : abc三个字母中的任何一个 [^abc]除了这三个字母中的任何一个字符
        
- 代表次数的量词元字符

        * : 0到多个
        + : 1到多个
        ? : 0次或1次 可有可无
        {n} : 正好n次；
        {n,} : n到多次
        {n,m} : n次到m次
        
- 量词出现在元字符后面 如\d+，限定出现在前面的元字符的次数 

        var str = '1223334444';
        var reg = /\d{2}/g;
        var res = str.match(reg);
        console.log(res)  //["12", "23", "33", "44", "44"]

        var str ='  我是空格君  ';
        var reg = /^\s+|\s+$/g; //匹配开头结尾空格
        var res = str.replace(reg,'');
        console.log('('+res+')')  //(我是空格君)
        
- 正则中的()和[]和重复子项 //拿出来单独说一下
- 一般[]中的字符没有特殊含义 如+就表示+但是像\w这样的还是有特殊含义的

        var str1 = 'abc';
        var str2 = 'dbc';
        var str3 = '.bc';
        var reg = /[ab.]bc/; //此时的.就表示.
        reg.test(str1)  //true
        reg.test(str2)  //false
        reg.test(str3)  //true

- []中，不会出现两位数

        [12]表示1或者2 不过[0-9]这样的表示0到9 [a-z]表示a到z
        例如:匹配从18到65年龄段所有的人
        var reg = /[18-65]/; // 这样写对么
        reg.test('50')
         //Uncaught SyntaxError: Invalid regular expression: /[18-65]/: Range out of order in character class
        //聪明的你想可能是8-6这里不对，于是改成[16-85]似乎可以匹配16到85的年龄段的，但实际上发现这也是不靠谱的

        实际上我们匹配这个18-65年龄段的正则我们要拆开来匹配
        我们拆成3部分来匹配 18-19  20-59 60-65 
        reg = /(18|19)|([2-5]\d)|(6[0-5])/;
        
## 正则运算符的优先级 ##  

- 正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。
- 相同优先级的会从左到右进行运算，不同优先级的运算先高后低

下面是常见的运算符的优先级排列
依次从最高到最低说明各种正则表达式运算符的优先级顺序：

        \ : 转义符
        (), (?:), (?=), []  => 圆括号和方括号
        *, +, ?, {n}, {n,}, {n,m}   => 量词限定符
        ^, $, \任何元字符、任何字符 
        |       => 替换，"或"操作

        字符具有高于替换运算符的优先级，一般用 | 的时候，为了提高 | 的优先级，我们常用()来提高优先级
        如： 匹配 food或者foot的时候 reg = /foo(t|d)/ 这样来匹配
             
## 正则的特性 ##      

- 贪婪性

        所谓的贪婪性就是正则在捕获时，每一次会尽可能多的去捕获符合条件的内容。
        如果我们想尽可能的少的去捕获符合条件的字符串的话，可以在量词元字符后加?

- 懒惰性

        懒惰性则是正则在成功捕获一次后不管后边的字符串有没有符合条件的都不再捕获。
        如果想捕获目标中所有符合条件的字符串的话，我们可以用标识符g来标明是全局捕获
        
        var str = '123aaa456';
        var reg = /\d+/;  //只捕获一次,一次尽可能多的捕获
        var res = str.match(reg)
        console.log(res)
        // ["123", index: 0, input: "123aaa456"]
        reg = /\d+?/g; //解决贪婪性、懒惰性
        res = str.match(reg)
        console.log(res)
        // ["1", "2", "3", "4", "5", "6"]
        
