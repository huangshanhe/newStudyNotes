# ...(扩展运算符)和assign()以及拷贝 #

- Object.assign() 只是一级属性复制，比浅拷贝多深拷贝了一层而已。用的时候，还是要注意这个问题的。

- 扩展运算符的解构赋值

        let { x, y, ...z } = null; // 运行时错误
        let { x, y, ...z } = undefined; // 运行时错误
        解构赋值必须是最后一个参数，否则会报错。

        let { ...x, y, z } = obj; // 句法错误
        let { x, ...y, ...z } = obj; // 句法错误
        上面代码中，解构赋值不是最后一个参数，所以会报错。

- 扩展运算符的拷贝

        注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。

        let obj = { a: { b: 1 } };
        let { ...x } = obj;
        obj.a.b = 2;
        x.a.b // 2
        上面代码中，x是解构赋值所在的对象，拷贝了对象obj的a属性。a属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。
        
        
        扩展运算符(...)用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。
        let z = {a:3,b:4};
        let n = {...z};
        n //{a:3,b:4}}

        这等同于使用Object.assign方法
        let aClone = {...a};
        //等同于
        let aClone = Object.assign({},a);

        
